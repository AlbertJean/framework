	//FreeImage_ZLibCompress();
	//FreeImage_ZLibUncompress();

//

	#if 0 // todo : remove test collision/SAT code
		gxPushMatrix();
		gxTranslatef(GFX_SX/2, GFX_SY/2, 0.f);
		gxScalef(4.f, 4.f, 1.f);
		{
			static int shape1Id = 0;
			static int shape2Id = 0;

			if (keyboard.wentDown(SDLK_1))
				shape1Id = (shape1Id + 1) % kBlockShape_COUNT;
			if (keyboard.wentDown(SDLK_2))
				shape2Id = (shape2Id + 1) % kBlockShape_COUNT;

			CollisionShape shape1 = Arena::getBlockCollision((BlockShape)shape1Id);
			CollisionShape shape2 = Arena::getBlockCollision((BlockShape)shape2Id);

			static float dx = BLOCK_SX;
			static float dy = 0.f;

			if (keyboard.isDown(SDLK_LEFT))
				dx -= 1.f;
			if (keyboard.isDown(SDLK_RIGHT))
				dx += 1.f;
			if (keyboard.isDown(SDLK_UP))
				dy -= 1.f;
			if (keyboard.isDown(SDLK_DOWN))
				dy += 1.f;

			CollisionShape shape3 = shape1;

			shape3.translate(dx, dy);

			float contactDistance;
			Vec2 contactNormal;
			
			const bool collision =
				shape3.checkCollision(shape2, Vec2(1.f, 0.f), contactDistance, contactNormal) ||
				shape3.checkCollision(shape2, Vec2(0.f, 1.f), contactDistance, contactNormal);
			//const bool collision = false;

			if (collision && keyboard.isDown(SDLK_c))
			{
				dx += contactNormal[0] * contactDistance;
				dy += contactNormal[1] * contactDistance;

				shape3 = shape1;
				shape3.translate(dx, dy);
			}

			if (collision)
				setColor(colorGreen);
			else
				setColor(colorRed);

			shape2.debugDraw();
			shape3.debugDraw();

			setColor(colorWhite);
		}
		gxPopMatrix();
	#endif

// Octree for color lookup

struct Octree;
struct OctreeNode;

struct OctreeNode
{
	OctreeNode(int level, int colorBits, Octree * octree);
	~OctreeNode();

	void addColor(const RGBQUAD & color, int colorBits, int level, Octree * octree, int __paletteIndex);
	int reduce();
	int getPaletteIndex(const RGBQUAD & color, int level);
	void increment(const RGBQUAD & color);

	bool m_leaf;

	int m_paletteIndex;
	int m_red, m_green, m_blue;
	int m_pixelCount;

	OctreeNode * m_children[8];
	OctreeNode * m_nextReducible;
};

static bool operator==(const RGBQUAD & q1, const RGBQUAD & q2)
{
	return
		q1.rgbRed   == q2.rgbRed &&
		q1.rgbGreen == q2.rgbGreen &&
		q1.rgbBlue  == q2.rgbBlue;
}

// mask used when getting the appropriate pixels for a given node
const int s_octreeMask[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

struct Octree
{
	Octree(int maxColorBits)
	{
		memset(this, 0, sizeof(*this));

		m_maxColorBits = maxColorBits;
		m_root = new OctreeNode(0, maxColorBits, this);
	}

	~Octree()
	{
		delete m_root;
	}

	void addColor(const RGBQUAD & color, int __paletteIndex)
	{
		if (m_previousNode && m_previousColor == color)
			m_previousNode->increment(color);
		else
		{
			m_previousColor = color;
			m_root->addColor(color, m_maxColorBits, 0, this, __paletteIndex);
		}
	}

	void reduce()
	{
		// find the deepest level containing at least one reducible node
		int index = m_maxColorBits - 1;
		while (index > 0 && !m_reducibleNodes[index])
			index--;

		// reduce the node most recently added to the list at level 'index'
		OctreeNode * node = m_reducibleNodes[index];
		m_reducibleNodes[index] = node->m_nextReducible;

		// decrement the leaf count after reducing the node
		m_leafCount -= node->reduce();

		// and just in case I've reduced the last color to be added, and the next color to
		// be added is the same, invalidate the previousNode
		m_previousNode = 0;
	}

	int getPaletteIndex(const RGBQUAD & color) const
	{
		return m_root->getPaletteIndex(color, 0);
	}

	OctreeNode * m_root;
	OctreeNode * m_reducibleNodes[9];
	OctreeNode * m_previousNode;
	RGBQUAD m_previousColor;
	int m_leafCount;
	int m_maxColorBits;
};

//

OctreeNode::OctreeNode(int level, int colorBits, Octree * octree)
{
	memset(this, 0, sizeof(*this));
	m_leaf = (level == colorBits);

	// if a leaf, increment the leaf count
	if (m_leaf)
	{
		octree->m_leafCount++;
		m_nextReducible = 0;
	}
	else
	{
		// otherwise add this to the reducible nodes
		m_nextReducible = octree->m_reducibleNodes[level];
		octree->m_reducibleNodes[level] = this;
	}
}

OctreeNode::~OctreeNode()
{
	for (int i = 0; i < 8; ++i)
		if (m_children[i])
			delete m_children[i];
}

void OctreeNode::addColor(const RGBQUAD & color, int colorBits, int level, Octree * octree, int __paletteIndex)
{
	// update the color information if this is a leaf
	if (m_leaf)
	{
		increment(color);
		octree->m_previousNode = this;

		m_paletteIndex = __paletteIndex;
	}
	else
	{
		increment(color); // fixme, remove?

		// go to the next level down in the tree
		const int shift = 7 - level;
		const int index =
			((color.rgbRed   & s_octreeMask[level]) >> (shift - 2)) |
			((color.rgbGreen & s_octreeMask[level]) >> (shift - 1)) |
			((color.rgbBlue  & s_octreeMask[level]) >> (shift - 0));

		OctreeNode *& child = m_children[index];

		if (!child)
			child = new OctreeNode(level + 1, colorBits, octree);

		child->addColor(color, colorBits, level + 1, octree, __paletteIndex);
	}
}

int OctreeNode::reduce()
{
	m_red = m_green = m_blue = 0;

	// loop through all children and add their information to this node

	int children = 0;

	for (int index = 0 ; index < 8 ; ++index)
	{
		if (m_children[index])
		{
			m_red += m_children[index]->m_red;
			m_green += m_children[index]->m_green;
			m_blue += m_children[index]->m_blue;
			m_pixelCount += m_children[index]->m_pixelCount;

			++children;

			delete m_children[index];
			m_children[index] = 0;
		}
	}

	// now change this to a leaf node
	m_leaf = true;

	// return the number of nodes to decrement the leaf count by
	return (children - 1);
}

int OctreeNode::getPaletteIndex(const RGBQUAD & color, int level)
{
	int paletteIndex = m_paletteIndex;

	if (!m_leaf)
	{
		const int shift = 7 - level;
		const int index =
			((color.rgbRed   & s_octreeMask[level]) >> (shift - 2)) |
			((color.rgbGreen & s_octreeMask[level]) >> (shift - 1)) |
			((color.rgbBlue  & s_octreeMask[level]) >> (shift - 0));

		if (m_children[index])
			paletteIndex = m_children[index]->getPaletteIndex(color, level + 1);
		else
		{
			// fixme, remove?

			int bestIndex = -1;
			int bestDistance = 1 << 30;
			for (int i = 0; i < 8; ++i)
			{
				if (m_children[i])
				{
					const int rChild = m_children[i]->m_red   / m_children[i]->m_pixelCount;
					const int gChild = m_children[i]->m_green / m_children[i]->m_pixelCount;
					const int bChild = m_children[i]->m_blue  / m_children[i]->m_pixelCount;
					const int rDelta = rChild - color.rgbRed;
					const int gDelta = gChild - color.rgbGreen;
					const int bDelta = bChild - color.rgbBlue;
					const int distance = rDelta * rDelta + gDelta * gDelta + bDelta * bDelta;
					if (distance < bestDistance)
					{
						bestIndex = i;
						bestDistance = distance;
					}
				}
			}

			if (bestIndex != -1)
				paletteIndex = m_children[bestIndex]->getPaletteIndex(color, level + 1);
			else
			{
				volatile int x = 0;
				//throw new Exception ( "Didn't expect this!" ) ;
			}
		}
	}

	return paletteIndex;
}

void OctreeNode::increment(const RGBQUAD & color)
{
	m_red += color.rgbRed;
	m_green += color.rgbGreen;
	m_blue += color.rgbBlue;

	m_pixelCount++;
}
