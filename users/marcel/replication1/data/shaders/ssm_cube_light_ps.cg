#define LIGHT_VALUE 0.5f
#define SHADOW_VALUE 0.0f

void main(
	in float4 position : TEXCOORD0,
	in float3 normal : TEXCOORD1,
	in const uniform samplerCUBE lt_cubeSSM,
	//in const uniform sampler2D lt_cubeSSMNoise,
	in const uniform float3 lt_pos,

	out half4 out_color : COLOR)
{
	const float3 delta = position.xyz - lt_pos;
	const half3 lt_dir = -normalize(delta);
	const float delta2 = dot(delta, delta);
	const half lt_dot = dot(normal, lt_dir);

	if (lt_dot < 0.0f)
	//if (lt_dot < 0.08f) // ~4.4 degrees
		out_color = half4(SHADOW_VALUE, SHADOW_VALUE, SHADOW_VALUE, 1.0f);
	else
	{
		half i = 0.0f;

		// FIXME, Not verry geometrically correct. :)
		const half3 d1 = normalize(cross(delta, half3(delta.y, delta.z, delta.x)));
		const half3 d2 = normalize(cross(delta, d1));

#if 0
		const float distance1 = texCUBE(lt_cubeSSM, delta).r;

		if (distance1 > delta2)
			i += LIGHT_VALUE;
#elif 1
		half offX[2] = { -0.5f, +0.5f };
		half offY[2] = { -0.5f, +0.5f };

		for (int j = 0; j < 2; ++j)
		{
			for (int k = 0; k < 2; ++k)
			{
				const half3 offset = half3(offX[j] * d1 + offY[k] * d2);
				const float distance1 = texCUBE(lt_cubeSSM, delta + offset).r;

				if (distance1 > delta2)
					i += LIGHT_VALUE / 4.0f;
			}
		}
#else
		#define N 2
		half2 off = half2(-0.5f, -0.5f);
		for (int j = 0; j <= N; ++j)
		{
			for (int k = 0; k <= N; ++k)
			{
				const half3 offset = half3(off.x * d1 + off.y * d2);
				const float distance1 = texCUBE(lt_cubeSSM, delta + offset).r;

				if (distance1 > delta2)
					i += 1.0f / (N * N);
					
				off.y += 1.0f / N;
			}
			
			off.x += 1.0f / N;
		}
#endif
		
		out_color = half4(half3(i), 1.0f);

		//out_color = distance1; return;
		//out_color = distance2; return;
		//out_color *= float4((normalize(delta) + float3(1.0f, 1.0f, 1.0f)) * 0.5f, 1.0f); return;
		//out_color = float4(normal, 1.0f); return;
		//out_color = float4(position.xyz, 1.0f); return;
	}
}