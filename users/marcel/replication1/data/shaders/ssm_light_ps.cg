#define LIGHT_VALUE 0.5f
#define SHADOW_VALUE 0.0f

void main(
	in float4 position : TEXCOORD0,
	in float3 normal : TEXCOORD1,
	in float4 texcoord : TEXCOORD2,

	in const uniform sampler2D lt_SSM,
	//in const uniform sampler2D lt_cubeSSMNoise,
	in const uniform float3 lt_pos,
	//in const uniform half3 lt_dir0,

	out half4 out_color : COLOR)
{
	const float3 delta = position.xyz - lt_pos;

	if (texcoord.w < 0.0f)
		out_color = float4(SHADOW_VALUE, SHADOW_VALUE, SHADOW_VALUE, 1.0f);
	else
	{
		const half3 lt_dir = -normalize(delta);
		const half lt_dot = dot(normal, lt_dir);

		if (lt_dot <= 0.0f)
			out_color = float4(SHADOW_VALUE, SHADOW_VALUE, SHADOW_VALUE, 1.0f);
		else
		{
#if 0
			float2 texcoords[9];

			//const float size = 1.0f / 512.0f * 20.0f;
			const float size = 1.0f / 512.0f;

			float2 texcoord2 = float2(texcoord.xy) / texcoord.z;

			texcoords[0] = float2(0.0f, 0.0f);

			texcoords[1] = float2(-size, -size);
			texcoords[2] = float2(+size, -size);
			texcoords[3] = float2(+size, +size);
			texcoords[4] = float2(-size, +size);

			texcoords[5] = float2(-size, 0.0f);
			texcoords[6] = float2(+size, 0.0f);
			texcoords[7] = float2(0.0f, -size);
			texcoords[8] = float2(0.0f, +size);

			/*
			float ang = 1.0f;
			float2x2 rot = float2x2(float2(cos(ang), -sin(ang)), float2(sin(ang), cos(ang)));
			*/

			float i = 0.0f;

			for (int j = 0; j < 9; ++j)
			{
#if 1
				//const float distance1 = tex2Dproj(lt_SSM, (texcoord + texcoords[j]).xyz).r;
				const float distance1 = tex2D(lt_SSM, texcoord2 + texcoords[j]).r;
				//const float distance1 = tex2D(lt_SSM, texcoord2 + mul(texcoords[j], rot)).r;
				const float distance2 = texcoord.z - 0.01f;

				if (distance2 < distance1)
					i += 1.0f;
#else
				i += tex2Dproj(lt_SSM, texcoord + texcoords[j]).r;
#endif
			}

			// FIXME, alpha.
			out_color = (i / 9.0f) * float4(LIGHT_VALUE, LIGHT_VALUE, LIGHT_VALUE, 1.0f);
#elif 1
			const float size = 1.0f / 512.0f;

			const float2 texcoord2 = float2(texcoord.xy) / texcoord.z;

			float i = 0.0f;

			for (float j = -2; j <= +2; ++j)
			{
				for (float k = -2; k <= +2; ++k)
				{
					//const float distance1 = tex2Dproj(lt_SSM, (texcoord + texcoords[j]).xyz).r;
					const float distance1 = tex2D(lt_SSM, texcoord2 + float2(j * size, k * size)).r;
					const float distance2 = texcoord.z - 0.01f;
					//const float distance2 = texcoord.z;

					if (distance2 < distance1)
						i += 1.0f;
				}
			}

			// FIXME, alpha.
			out_color = (i / 25.0f) * float4(LIGHT_VALUE, LIGHT_VALUE, LIGHT_VALUE, 1.0f);
#else
			const float distance1 = tex2Dproj(lt_SSM, texcoord.xyz).r;
			const float distance2 = texcoord.z - 0.01f;

			if (distance2 < distance1)
				out_color = float4(1.0f, 1.0f, 1.0f, 1.0f);
			else
				out_color = float4(SHADOW_VALUE, SHADOW_VALUE, SHADOW_VALUE, 1.0f);
#endif
		}

	#if 0
		half um = 1.0f - dot(-lt_dir, lt_dir0);
		// um = cos(3.14/2) = min.
		// um = 1 = max.
		half um_min = cos(3.14f / 2.0f);
		half um_max = 1.0f;
		half l = -(um - um_min) / (um_max - um_min);

		out_color = out_color * l;
	#endif
	}
}
