#define WORKAROUND 1

void main(
		  in float3 in_ray_dir : TEXCOORD0,
		  in float2 in_scr_pos : TEXCOORD1,

		  uniform float4 sphere,
		  uniform sampler2D depth,
		  uniform float3 color,
		  uniform float4x4 p,

		#if WORKAROUND
		  out float4 out_color : COLOR)
		#else
		  out float4 out_color : COLOR,
		  out float out_depth : DEPTH)
		#endif
{
	//float out_depth;

#if WORKAROUND
	out_color = float4(1.0f, 1.0f, 1.0f, 0.1f);
#else
	const float3 ray_dir = normalize(in_ray_dir);

	// Intersect sphere.
	const float b = -dot(sphere.xyz, ray_dir);
	const float c = dot(sphere.xyz, sphere.xyz) - sphere.w * sphere.w;
	float d = b * b - c;

	if (d < 0.0f)
		discard;
	else
	{
		d = sqrt(d);

		float t1 = (-b - d);
		float t2 = (-b + d);

		if (t1 < 0.0f) t1 = 0.0f;
		if (t2 < 0.0f) t2 = 0.0f;

		#if 0
		const float z = tex2D(depth, in_scr_pos).r;

		//out_color = float4(float3(z / 100.0f), 1.0f);
		//return;

		if (t1 > z) t1 = z;
		if (t2 > z) t2 = z;

		/*
		if (t2 > d2)
		{
			out_color = float4(0.0f, 1.0f, 0.0f, 1.0f);
			return;
		}*/
		#endif

		#if 1
		const float dt = t2 - t1;
		float f = dt / (sphere.w * 2.0f);
		//f *= f;
		#else
		float f = 0.0f;

		const float v1 = t1;
		const float vd = (t2 - t1) / 10.0f;
		for (float i = 0.0f; i <= 10.0f; i += 1.0f)
		{
			const float vv = v1 + vd * i;
			const float3 p = ray_dir * vv - sphere.xyz;
			//float v = noise(p.x);
			const float v = sin(p.x * 1.0f) + sin(sphere.w + p.y * 0.765) + sin(p.z * 0.432f);
			if (v >= 0.0f)
			//if (v >= 0.5f)
				f += 1.0f / 11.0f;
		}
		f *= (t2 - t1) / (sphere.w * 2.0f);
		#endif

		//out_color = float4(color, f);
		const float f2 = f * f;
		const float f3 = f * f2;
		out_color = float4(color * float3(f, f2, f3), 1.0f);

		// FIXME: How to convert to z-buffer value?
		// d = (z - near) / (far - near) ?
		const float4 p1 = float4(ray_dir * t1, 1.0f);
		const float4 p2 = mul(p1, p);
		out_depth = p2.z / p2.w;
	}
#endif
}
