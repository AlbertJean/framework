#include "framework.h"
#include "Log.h"
#include "StringEx.h"
#include <atomic>

// for inbound OSC messages
#include "osc/OscPacketListener.h"

// for outbound OSC messages
#include "ip/UdpSocket.h"
#include "osc/OscOutboundPacketStream.h"

#define OSC_BUFFER_SIZE 2048

const int GFX_SX = 500;
const int GFX_SY = 700;

std::atomic<bool> s_quitRequested(false);

static SDL_mutex * s_mutex = nullptr;

#define UPDATE_SLOW_INTERVAL 20
#define REPAINT_INTERVAL 500
#define SEND_FAKE_SENSOR_DATA_INTERVAL 1000

// OSC message history

struct OscMessageHistory
{
	struct Elem
	{
		std::string address;
		std::vector<float> values;
		std::vector<float> values_slow;
		std::vector<float> values_gradient;
		std::vector<float> values_gradient_previousValues; // value of 'values' last time gradient was calculated
		uint64_t lastReceiveTime = 0;
		bool isAutoGenerated = false;
		bool isSigned = false;
		
		int recordCount = 0;
		
		void init(const char * _address)
		{
			address = _address;
			
			if (String::EndsWith(address, "_slow"))
				isAutoGenerated = true;
			
			if (String::EndsWith(address, "_gradient"))
			{
				isAutoGenerated = true;
				isSigned = true;
			}
		}
		
		void record(const std::vector<float> & _values)
		{
			values = _values;
			
			recordCount++;
		}
		
		void updateSlow(const float dt)
		{
			// make sure the arrays have the correct size
			
			values_slow.resize(values.size(), 0.f);
			
			// update
			
			const float retain = std::pow(.8f, dt);
			
			for (size_t i = 0; i < values.size(); ++i)
			{
				const float oldValue = values_slow[i];
				const float newValue = values[i];
				
				values_slow[i] = oldValue * retain + newValue * (1.f - retain);
			}
		}
		
		void calculateGradient(const float dt)
		{
			// make sure the arrays have the correct size
			
			values_gradient.resize(values_slow.size(), 0.f);
			values_gradient_previousValues.resize(values_slow.size(), 0.f);
			
			for (size_t i = 0; i < values_slow.size(); ++i)
			{
				const float oldValue = values_gradient_previousValues[i];
				const float newValue = values_slow[i];
				
				const float delta = newValue - oldValue;
				const float changePerSecond = delta / dt;
				
				values_gradient[i] = changePerSecond;
			}
			
			values_gradient_previousValues = values_slow;
		}
	};
	
	std::map<std::string, Elem> elems;
	
	Elem & getElem(const char * address)
	{
		auto elemItr = elems.find(address);
		
		if (elemItr == elems.end())
		{
			auto & elem = elems[address];
			
			elem.init(address);
			
			return elem;
		}
		else
		{
			return elemItr->second;
		}
	}
};

static OscMessageHistory s_oscMessageHistory;

// OSC receiver

struct OscPacketListener : osc::OscPacketListener
{
	virtual void ProcessMessage(const osc::ReceivedMessage & m, const IpEndpointName & remoteEndpoint) override
	{
		SDL_LockMutex(s_mutex);
		{
			// todo : check address
			
			const char * address = m.AddressPattern();
			
			if (address != nullptr)
			{
				// todo : record value
				
				OscMessageHistory::Elem & elem = s_oscMessageHistory.getElem(address);
				
				std::vector<float> values;
				
				for (auto aItr = m.ArgumentsBegin(); aItr != m.ArgumentsEnd(); ++aItr)
				{
					auto & a = *aItr;
					
					const float value = a.IsFloat() ? a.AsFloat() : 0.f;
					
					values.push_back(value);
				}
				
				elem.record(values);
			}
		}
		SDL_UnlockMutex(s_mutex);
	}
};

// IpEndpointName::ANY_ADDRESS

struct OscReceiver
{
	OscPacketListener * packetListener = nullptr;
	UdpListeningReceiveSocket * receiveSocket = nullptr;
	
	SDL_Thread * receiveThread = nullptr;
	
	~OscReceiver()
	{
		shut();
	}
	
	void init(const char * ipAddress, const int udpPort)
	{
		packetListener = new OscPacketListener();
	
		receiveSocket = new UdpListeningReceiveSocket(IpEndpointName(ipAddress, udpPort), packetListener);
		
		receiveThread = SDL_CreateThread(receiveThreadProc, "OSC Receive", this);
	}
	
	void shut()
	{
		LOG_DBG("terminating OSC receive thread", 0);
		
		if (receiveSocket != nullptr)
		{
			receiveSocket->AsynchronousBreak();
		}
		
		if (receiveThread != nullptr)
		{
			SDL_WaitThread(receiveThread, nullptr);
			receiveThread = nullptr;
		}
		
		LOG_DBG("terminating OSC receive thread [done]", 0);
		
		LOG_DBG("terminating OSC UDP receive socket", 0);
		
		delete receiveSocket;
		receiveSocket = nullptr;
		
		LOG_DBG("terminating OSC UDP receive socket [done]", 0);
		
		delete packetListener;
		packetListener = nullptr;
	}
	
	static int receiveThreadProc(void * obj)
	{
		OscReceiver * self = (OscReceiver*)obj;
		
		self->receiveSocket->Run();
		
		return 0;
	}
};

//

struct OscSender
{
	UdpTransmitSocket * transmitSocket;
	
	void init(const char * ipAddress, const int udpPort)
	{
		transmitSocket = new UdpTransmitSocket(IpEndpointName(ipAddress, udpPort));
	}
	
	void shut()
	{
		if (transmitSocket != nullptr)
		{
			delete transmitSocket;
			transmitSocket = nullptr;
		}
	}
	
	void send(const void * data, const int dataSize)
	{
		if (transmitSocket != nullptr)
		{
			transmitSocket->Send((char*)data, dataSize);
		}
	}
};

// event timer

struct EventTimer
{
	int event = -1;
	int interval = 0;
	SDL_Thread * thread = nullptr;
	std::atomic<bool> stop;
	
	EventTimer()
		: stop(false)
	{
	}
	
	~EventTimer()
	{
		shut();
	}
	
	void init(const int _event, const int _interval)
	{
		event = _event;
		interval = _interval;
		
		thread = SDL_CreateThread(timerThreadProc, "Event Timer", this);
	}
	
	void shut()
	{
		stop = true;
		
		SDL_WaitThread(thread, nullptr);
		thread = nullptr;
	}
	
	static int timerThreadProc(void * obj)
	{
		EventTimer * self = (EventTimer*)obj;
		
		while (self->stop == false)
		{
			SDL_Delay(self->interval);
			
			SDL_Event e;
			e.type = self->event;
			SDL_PushEvent(&e);
		}
		
		return 0;
	}
};

// slow-changing value update thread

static void updateSlow(OscSender & sender, const float dt)
{
	for (auto & elemItr : s_oscMessageHistory.elems)
	{
		auto & elem = elemItr.second;
		
		if (elem.isAutoGenerated)
			continue;
		
		// update slow-changing value
		
		elem.updateSlow(dt);
		
		// send slow-changing value
		
		{
			char address[256];
			sprintf_s(address, sizeof(address), "%s_slow", elem.address.c_str());
			
			char buffer[OSC_BUFFER_SIZE];
			osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
			
			p << osc::BeginMessage(address);
			{
				for (auto & value : elem.values_slow)
					p << value;
			}
			p << osc::EndMessage;
			
			sender.send(p.Data(), p.Size());
		}
	}
}

static void updateGradient(OscSender & sender, const float dt)
{
	for (auto & elemItr : s_oscMessageHistory.elems)
	{
		auto & elem = elemItr.second;
		
		if (elem.isAutoGenerated)
			continue;
		
		// calculate gradient
		
		elem.calculateGradient(dt);
	
		// send gradient
		
		{
			char address[256];
			sprintf_s(address, sizeof(address), "%s_gradient", elem.address.c_str());
			
			char buffer[OSC_BUFFER_SIZE];
			osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
			
			p << osc::BeginMessage(address);
			{
				for (auto & value : elem.values_gradient)
					p << value;
			}
			p << osc::EndMessage;
			
			sender.send(p.Data(), p.Size());
		}
	}
}

static int updateSlowThreadProc(void * obj)
{
	OscSender * sender = (OscSender*)obj;
	
	while (!s_quitRequested)
	{
		SDL_LockMutex(s_mutex);
		{
			const float dt = UPDATE_SLOW_INTERVAL / 1000.f;
			
			updateSlow(*sender, dt);
			
			updateGradient(*sender, dt);
		}
		SDL_UnlockMutex(s_mutex);
		
		SDL_Delay(UPDATE_SLOW_INTERVAL);
	}
	
	return 0;
}

static SDL_Thread * s_updateSlowThread = nullptr;

//

#include "Noise.h"

static bool s_sendFakeDataEnabled = false;

static void sendFakeCamera(OscSender & sender, const float rateOfChange, const char * addressPrefix)
{
	const int sx = 16;
	const int sy = 12;
	
	float values[sy][sx];
	
	float total = 0.f;
	
	for (int y = 0; y < sy; ++y)
	{
		for (int x = 0; x < sx; ++x)
		{
			const float value = scaled_octave_noise_3d(8, .6f, .1f, 0.f, 1.f, x, y, framework.time * rateOfChange);
			
			values[y][x] = value;
			
			total += value;
		}
	}
	
	const float average = total / (sx * sy);
	
	char buffer[OSC_BUFFER_SIZE];
	osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
	p << osc::BeginBundleImmediate;
	{
		char rawAddress[256];
		sprintf_s(rawAddress, sizeof(rawAddress), "%s/raw", addressPrefix);
		p << osc::BeginMessage(rawAddress);
		for (int y = 0; y < sy; ++y)
			for (int x = 0; x < sx; ++x)
				p << values[y][x];
		p << osc::EndMessage;
		
		char averageAddress[256];
		sprintf_s(averageAddress, sizeof(averageAddress), "%s/average", addressPrefix);
		p << osc::BeginMessage(averageAddress);
		p << average;
		p << osc::EndMessage;
	}
	p << osc::EndBundle;

	sender.send(p.Data(), p.Size());
}

static int sendFakeSensorDataThreadProc(void * obj)
{
	OscSender * sender = (OscSender*)obj;
	
	while (!s_quitRequested)
	{
		if (s_sendFakeDataEnabled)
		{
			SDL_LockMutex(s_mutex);
			{
				char buffer[OSC_BUFFER_SIZE];
				osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
				p << osc::BeginBundleImmediate;
				{
					p << osc::BeginMessage("/humidity");
					p << float(std::sin(framework.time * 2.0 * M_PI / 60.0) + 1.f) / 2.f;
					p << osc::EndMessage;
				}
				p << osc::EndBundle;
				
				sender->send(p.Data(), p.Size());
				
				//
				
				sendFakeCamera(*sender, .1f, "/env/light");
				
				sendFakeCamera(*sender, 1.f, "/room/light");
			}
			SDL_UnlockMutex(s_mutex);
		}
		
		SDL_Delay(SEND_FAKE_SENSOR_DATA_INTERVAL);
	}
	
	return 0;
}

static SDL_Thread * s_sendFakeSensorDataThread = nullptr;

//

static int drawValueGrid(const std::vector<float> & values, const int gridSx, const int gridSy, const bool isSigned)
{
	Assert(gridSx * gridSy == values.size());
	
	const int kScale = 6;
	
	gxPushMatrix();
	gxScalef(kScale, kScale, 0);
	hqBegin(HQ_FILLED_RECTS);
	{
		setColor(0, 0, 0, 200);
		hqFillRect(0, 0, gridSx, gridSy);
		setAlpha(255);
	}
	hqEnd();
	gxTranslatef(.5f, .5f, 0);
	hqBegin(HQ_FILLED_CIRCLES);
	{
		for (int y = 0; y < gridSy; ++y)
		{
			for (int x = 0; x < gridSx; ++x)
			{
				const int index = x + y * gridSx;
				
				const float value = (index < values.size()) ? values[index] : 0.f;
				
				if (isSigned)
					//setLumif(std::abs(value));
					setLumif((value + 1.f) / 2.f);
				else
					setLumif(value);
				
				hqFillCircle(x, y, .4f);
			}
		}
	}
	hqEnd();
	gxPopMatrix();
	
	return gridSy * kScale;
}

int main(int argc, char * argv[])
{
	const int kFontSize = 14;
	
	if (!framework.init(0, nullptr, GFX_SX, GFX_SY))
		return -1;
	
	s_mutex = SDL_CreateMutex();
	
	OscReceiver * receiver = new OscReceiver();
	receiver->init("127.0.0.1", 8000);
	
	OscSender * sender = new OscSender();
	sender->init("255.255.255.255", 8000);
	
	const int repaintEvent = SDL_RegisterEvents(1);
	
	EventTimer * repaintTimer = new EventTimer();
	repaintTimer->init(repaintEvent, REPAINT_INTERVAL);
	
	s_updateSlowThread = SDL_CreateThread(updateSlowThreadProc, "Update Slow", sender);
	
	s_sendFakeSensorDataThread = SDL_CreateThread(sendFakeSensorDataThreadProc, "Send Fake Sensor Data", sender);
	
	bool continousRepaint = false;
	
	for (;;)
	{
		framework.waitForEvents = !continousRepaint;
		
		framework.process();
		
		if (keyboard.wentDown(SDLK_ESCAPE))
			framework.quitRequested = true;
		
		if (framework.quitRequested)
			break;
		
		bool repaint = false;
		
		//if (continousRepaint)
			repaint = true;
		
		for (auto & event : framework.events)
		{
			if (event.type == repaintEvent)
			{
				repaint = true;
			}
		}
		
		if (keyboard.wentDown(SDLK_f))
		{
			s_sendFakeDataEnabled = !s_sendFakeDataEnabled;
		}
		
		if (keyboard.wentDown(SDLK_p))
		{
			continousRepaint = !continousRepaint;
		}
		
		if (repaint)
		{
			OscMessageHistory history;
			
			SDL_LockMutex(s_mutex);
			{
				history = s_oscMessageHistory;
			}
			SDL_UnlockMutex(s_mutex);
			
			framework.beginDraw(200, 200, 200, 0);
			{
				setFont("calibri.ttf");
				pushFontMode(FONT_SDF);
				
				gxPushMatrix();
				{
					gxTranslatef(5, 5, 0);
					setColor(colorWhite);
					setLumi(40);
					
					drawText(0, 0, kFontSize, +1, +1, "F = change send fake sensor data (%s), P = change power-save (%s)",
						s_sendFakeDataEnabled ? "enable" : "disabled",
						continousRepaint ? "disabled" : "enabled");
					gxTranslatef(0, 24, 0);
					
					for (auto & elemItr : history.elems)
					{
						auto & elem = elemItr.second;
						
						int sy = 16;
						
						gxPushMatrix();
						{
							setLumi(40);
							
							drawText(0, 0, kFontSize, +1, +1, "%s", elem.address.c_str());
							gxTranslatef(200, 0, 0);
							
							if (elem.isAutoGenerated)
							{
								drawText(0, 0, kFontSize, +1, +1, "Sent");
								gxTranslatef(60, 0, 0);
								drawText(0, 0, kFontSize, +1, +1, "x %d", elem.recordCount);
								gxTranslatef(80, 0, 0);
							}
							else
							{
								drawText(0, 0, kFontSize, +1, +1, "Received");
								gxTranslatef(60, 0, 0);
								drawText(0, 0, kFontSize, +1, +1, "x %d", elem.recordCount);
								gxTranslatef(80, 0, 0);
							}
							
							if (elem.values.size() > 1)
							{
								if (elem.values.size() == 16 * 12)
								{
									// this is a camera feed!
									
									const int gridSy = drawValueGrid(elem.values, 16, 12, elem.isSigned);
									
									sy = std::max(sy, gridSy + 4);
								}
								else
								{
									const int gridSy = drawValueGrid(elem.values, elem.values.size(), 1, elem.isSigned);
									
									sy = std::max(sy, gridSy + 4);
								}
							}
							else
							{
								for (auto & value : elem.values)
								{
									drawText(0, 0, kFontSize, +1, +1, "%.2f", value);
									gxTranslatef(32, 0, 0);
								}
							}
						}
						gxPopMatrix();
						
						gxTranslatef(0, sy, 0);
					}
				}
				gxPopMatrix();
				
				popFontMode();
			}
			framework.endDraw();
		}
	}
	
	s_quitRequested = true;
	
	SDL_WaitThread(s_sendFakeSensorDataThread, nullptr);
	
	SDL_WaitThread(s_updateSlowThread, nullptr);
	
	delete repaintTimer;
	repaintTimer = nullptr;
	
	delete receiver;
	receiver = nullptr;
	
	SDL_DestroyMutex(s_mutex);
	s_mutex = nullptr;
	
	Font("calibri.ttf").saveCache();
	
	framework.shutdown();
	
	return 0;
}
